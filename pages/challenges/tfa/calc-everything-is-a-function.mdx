import { Callout } from 'nextra/components'
import Videos from '@/components/videos'
import {frontmatter} from '@/src/frontmatter'
import Rubric from '@/components/rubric'
import ReposForLab from '@/components/repos-for-lab'

##  Proposed sequence of labs about the calculator for course 23/24

The PL labs of this group:

while -> left-side -> array-maps-and-null

corresponds to the branches

- while
- left-side
- array-map

of the repo [functions-solution](https://github.com/ULL-ESIT-PL/functions-solution)

```
➜  functions-solution git:(left-side) git remote -v
origin  git@github.com:ULL-ESIT-PL/functions-solution.git (fetch)
origin  git@github.com:ULL-ESIT-PL/functions-solution.git (push)
pcgull-solution https://github.com/ULL-ESIT-PL-2223/arith2js-parallel-computing-group-parallel.git (fetch)
pcgull-solution https://github.com/ULL-ESIT-PL-2223/arith2js-parallel-computing-group-parallel.git (push)
scope-intro-solution    git@github.com:ULL-ESIT-PL/calc2js-solution.git (fetch)
scope-intro-solution    git@github.com:ULL-ESIT-PL/calc2js-solution.git (push)
upstream        https://github.com/ULL-ESIT-PL/arith2js-solution.git (fetch)
upstream        https://github.com/ULL-ESIT-PL/arith2js-solution.git (push)
```

at

```
➜  functions-solution git:(left-side) pwd -P
/Users/casianorodriguezleon/campus-virtual/2223/pl2223/practicas/functions/functions-solution
```

## Goal: Functions on the left side of an assignment

In the calculator language, the left side of an assignment only an ID is allowed. We want to extend the language to allow the modification of functions.

### Introduction

We want to extend the language so that on the left side of an assignment you can have a function modification. For example, the following code should be valid:

```js showLineNumbers {2,3} filename="test/data/input/fun.calc"
f = fun(x) { x + 1 },
f(0+2) = 8, # Constant folding lab for the future 0+1, 1*8
f(1+3) = 1000,
write(f(0)), # 1
write(f(2)), # 8
write(f(4))  # 1000
```

The translation of the former code can be s.t. like the following:

```js showLineNumbers {11,13} filename="test/data/expectedjs/fun.js"
#!/usr/bin/env node
const { Complex, memoize, write } = require("/Users/casianorodriguezleon/campus-virtual/2223/pl2223/practicas/functions/functions-solution/src/support-lib.js");
/* End of support code */
let $f;

(
    (
        (
          (
            $f = function ($x) { return $x.add(Complex("1")); }, 
            $f = memoize($f, [Complex("0").add(Complex("2"))], Complex("8"), 0)
          ), 
          $f = memoize($f, [Complex("1").add(Complex("3"))], Complex("1000"), 0)
        ), 
        write($f(Complex("0")))
    ), 
    write($f(Complex("2")))
), 
write($f(Complex("4")));
```

### Modifying a function with nested calls on the left side

let's consider the following example in which a nested call occurs in the left hand side of the assignment:

```js showLineNumbers {3} filename="test/data/input/fun-on-the-left-side.calc"
➜  functions-solution git:(left-side) cat test/data/input/fun-on-the-left-side.calc            
f = fun(x) { fun(y) { x + y } },
f(2)(3) = 8, 
write(f(2)(3)),  # 8
write(f(2)(5)),  # 7
write(f(3)(1)),  # 4
write(f(9)(2))   # 11
```

The former code modifies the code of the function `$f`  created in the first assignment

```js showLineNumbers {16} filename="test/data/expectedjs/fun-on-the-left-side.js"
➜  functions-solution git:(left-side) ✗ bin/calc2js.mjs test/data/input/fun-on-the-left-side.calc
#!/usr/bin/env node
const { memoize, Complex, write } = require("/Users/casianorodriguezleon/campus-virtual/2223/pl2223/practicas/functions/functions-solution/src/support-lib.js"); 
/* End of support code */
 
let $f;
(
    (
        (
            (
                $f = function($x) {
                    return function($y) {
                        return $x.add($y);
                    };
                }, 
                $f = memoize($f, [Complex("2"), Complex("3")], Complex("8"), 0)
            ), 
            write($f(Complex("2"))(Complex("3"))) // 8
        ), 
        write($f(Complex("2"))(Complex("5")))  // 7
    ), 
    write($f(Complex("3"))(Complex("1")))  // 4
), 
write($f(Complex("9"))(Complex("2"))); // 11
```

### Current implementation

```js showLineNumbers {1,3} filename="src/support-lib.js"
function memoize(f, cacheArgs, cacheValue, i) {
  let cacheArgument = cacheArgs[i];
  
  return function(...args) {
    let auxF = f;
    
     if (cacheArgument == null) return cacheValue;
     if (args[0].equals(cacheArgument)) {
      auxF = f(...args);
      if (cacheArgs.length === i+1) return cacheValue;
     }
     if (args[0].equals(cacheArgument) && cacheArgs.length > i+1) {
       return memoize(auxF, cacheArgs, cacheValue, i+1)
     }
     return auxF(...args);
   }
}
```

### References on memoization

See 
1. My old notes in [memoization](https://crguezl.github.io/apuntes-ruby/node167.html) of the `fib`onacci function in Ruby and 
2. The [wikipedia section on Memoization](https://en.wikipedia.org/wiki/Memoization).
3. [Memoization of the require in Egg](https://crguezl.github.io/ull-esit-1617/_book/practicas/practica-egg-4.html)
4. [memoize](https://github.com/sindresorhus/memoize) npm package by Sindre Sorhus
5. [Memoization of Multi-Parametered Functions in JavaScript](https://medium.com/@joedski/memoization-of-multi-parametered-functions-in-javascript-8508e89ba545) by Joseph Sikorski. Jul 14, 2017

## Goal: Array notation for functions and otherwise

The notation

```js
a = [4;7;9 ... 0]
```

defines `a` as a function such that `a(0)` returns `4`, `a(1)` returns `7`, and `a(2)` returns `9` and otherwise 
returns `0`.

If the `... expression` is not present, the function returns an special object called 
`null` for any argument not explicitly defined.

```js showLineNumbers filename: test/data/input/arr.calc 
a = [4+2;5+3i;9-i],
print(a(0)), # { re: 6, im: 0 }
a(1) = 333,  
print(a(1)), # { re: 333, im: 0 }
print(a(9)), # null
print(a)     #  { re: 6, im: 0 }, { re: 333, im: 0 }, { re: 9, im: -1 } ]
```

The former code translates to

```js showLineNumbers filename: test/data/expectedjs/arr.js {14-18}
➜  functions-solution git:(array-map) ✗ bin/calc2js.mjs test/data/input/arr.calc | npx prettier --parser babel
#!/usr/bin/env node
const {
    arr,
    Complex,
    print,
    memoize
} = require('/Users/casianorodriguezleon/campus-virtual/2223/pl2223/practicas/functions/functions-solution/src/support-lib.js');

/* End of support code */

let $a;

((((($a = arr(
    Complex('4').add(Complex('2')),
    Complex('5').add(Complex('3i')),
    Complex('9').sub(Complex('i'))
)),
print($a(Complex('0')))),
($a = memoize($a, [Complex('1')], Complex('333'), 0))),
print($a(Complex('1')))),
print($a(Complex('9')))),
    print($a);
```

## Hashes/Maps/Objects

Proposed syntax for hashes/maps:

```js
a = { 4: 5; 7: 3i; "hello": 6 ... 0}
```

meaning a function that `a(4) = 5`, `a(7) = 3i`, `a("hello") = 6` and otherwise `a(x) = 0` for all `x`.

An alternative to explore/study is to consider the introduction of the `meth` keyword that will define a functions that usea the "object" as a context. For example, the following code:

```js
b = { "x": 5;  "add": meth(z) { x + z} },
f("add")(3) # 8
```

## null object 

Introduce `null` as an extension of `0` and the empty string `""` so that it holds the following properties:

```js
null + 4 == 4,
null + "hello" == "hello",
null * 4 == 0,
4 - null == 4,
fun(x) { x + 1 } * null # is the same as fun(x) { 0 },
null && true == false,
```

Notice that if `a` is a function like in the former example `a * null` is the function `a(x) = 0` for any `x`.